{"ast":null,"code":"// src/api.js\nimport axios from \"axios\";\nconst BASE_URL = \"http://localhost:3000/api\";\n\n// Tạo một instance axios với cấu hình cơ sở\nconst api = axios.create({\n  baseURL: BASE_URL\n});\n\n// 1. Request Interceptor: Tự động đính kèm AccessToken vào header\napi.interceptors.request.use(config => {\n  const token = localStorage.getItem(\"accessToken\");\n  if (token) {\n    config.headers[\"Authorization\"] = \"Bearer \" + token;\n  }\n  return config;\n}, error => {\n  return Promise.reject(error);\n});\n\n// Biến cờ để theo dõi việc đang refresh token\nlet isRefreshing = false;\n\n// 2. Response Interceptor: Xử lý khi AccessToken hết hạn (lỗi 401)\napi.interceptors.response.use(response => {\n  // Nếu request thành công, trả về response\n  return response;\n}, async error => {\n  const originalRequest = error.config;\n\n  // Nếu lỗi là 401 VÀ request này không phải là request refresh (tránh lặp vô hạn)\n  if (error.response.status === 401 && !originalRequest._retry) {\n    if (isRefreshing) {\n      // Nếu đang refresh, không thực hiện nữa mà chờ\n      return Promise.reject(error);\n    }\n    originalRequest._retry = true; // Đánh dấu đây là request đã thử lại\n    isRefreshing = true;\n    const refreshToken = localStorage.getItem(\"refreshToken\");\n    try {\n      // Gọi API /auth/refresh (dùng axios gốc, không dùng 'api' để tránh lặp)\n      const rs = await axios.post(`${BASE_URL}/auth/refresh`, {\n        refreshToken: refreshToken\n      });\n      const {\n        accessToken\n      } = rs.data;\n\n      // Cập nhật AT mới vào localStorage\n      localStorage.setItem(\"accessToken\", accessToken);\n\n      // Cập nhật header cho instance 'api'\n      api.defaults.headers.common[\"Authorization\"] = \"Bearer \" + accessToken;\n      // Cập nhật header cho request gốc\n      originalRequest.headers[\"Authorization\"] = \"Bearer \" + accessToken;\n      isRefreshing = false;\n\n      // Thực hiện lại request gốc với AT mới\n      return api(originalRequest);\n    } catch (_error) {\n      // Nếu Refresh Token cũng hết hạn hoặc không hợp lệ\n      console.error(\"Refresh token is invalid. Logging out...\", _error);\n\n      // Xóa hết token và user info\n      localStorage.removeItem(\"accessToken\");\n      localStorage.removeItem(\"refreshToken\");\n      localStorage.removeItem(\"user\");\n      isRefreshing = false;\n\n      // Điều hướng về trang đăng nhập\n      // (Cách tốt nhất là dùng state management, nhưng window.location cũng hoạt động)\n      window.location.href = \"/\";\n      return Promise.reject(_error);\n    }\n  }\n\n  // Trả về lỗi nếu không phải 401\n  return Promise.reject(error);\n});\nexport default api;","map":{"version":3,"names":["axios","BASE_URL","api","create","baseURL","interceptors","request","use","config","token","localStorage","getItem","headers","error","Promise","reject","isRefreshing","response","originalRequest","status","_retry","refreshToken","rs","post","accessToken","data","setItem","defaults","common","_error","console","removeItem","window","location","href"],"sources":["/Users/wocten/Documents/group2-project/frontend/src/api.js"],"sourcesContent":["// src/api.js\nimport axios from \"axios\";\n\nconst BASE_URL = \"http://localhost:3000/api\";\n\n// Tạo một instance axios với cấu hình cơ sở\nconst api = axios.create({\n  baseURL: BASE_URL,\n});\n\n// 1. Request Interceptor: Tự động đính kèm AccessToken vào header\napi.interceptors.request.use(\n  (config) => {\n    const token = localStorage.getItem(\"accessToken\");\n    if (token) {\n      config.headers[\"Authorization\"] = \"Bearer \" + token;\n    }\n    return config;\n  },\n  (error) => {\n    return Promise.reject(error);\n  }\n);\n\n// Biến cờ để theo dõi việc đang refresh token\nlet isRefreshing = false;\n\n// 2. Response Interceptor: Xử lý khi AccessToken hết hạn (lỗi 401)\napi.interceptors.response.use(\n  (response) => {\n    // Nếu request thành công, trả về response\n    return response;\n  },\n  async (error) => {\n    const originalRequest = error.config;\n\n    // Nếu lỗi là 401 VÀ request này không phải là request refresh (tránh lặp vô hạn)\n    if (error.response.status === 401 && !originalRequest._retry) {\n      \n      if (isRefreshing) {\n        // Nếu đang refresh, không thực hiện nữa mà chờ\n        return Promise.reject(error);\n      }\n\n      originalRequest._retry = true; // Đánh dấu đây là request đã thử lại\n      isRefreshing = true;\n\n      const refreshToken = localStorage.getItem(\"refreshToken\");\n\n      try {\n        // Gọi API /auth/refresh (dùng axios gốc, không dùng 'api' để tránh lặp)\n        const rs = await axios.post(`${BASE_URL}/auth/refresh`, {\n          refreshToken: refreshToken,\n        });\n\n        const { accessToken } = rs.data;\n\n        // Cập nhật AT mới vào localStorage\n        localStorage.setItem(\"accessToken\", accessToken);\n\n        // Cập nhật header cho instance 'api'\n        api.defaults.headers.common[\"Authorization\"] = \"Bearer \" + accessToken;\n        // Cập nhật header cho request gốc\n        originalRequest.headers[\"Authorization\"] = \"Bearer \" + accessToken;\n\n        isRefreshing = false;\n\n        // Thực hiện lại request gốc với AT mới\n        return api(originalRequest);\n\n      } catch (_error) {\n        // Nếu Refresh Token cũng hết hạn hoặc không hợp lệ\n        console.error(\"Refresh token is invalid. Logging out...\", _error);\n        \n        // Xóa hết token và user info\n        localStorage.removeItem(\"accessToken\");\n        localStorage.removeItem(\"refreshToken\");\n        localStorage.removeItem(\"user\");\n        \n        isRefreshing = false;\n        \n        // Điều hướng về trang đăng nhập\n        // (Cách tốt nhất là dùng state management, nhưng window.location cũng hoạt động)\n        window.location.href = \"/\"; \n        \n        return Promise.reject(_error);\n      }\n    }\n\n    // Trả về lỗi nếu không phải 401\n    return Promise.reject(error);\n  }\n);\n\nexport default api;"],"mappings":"AAAA;AACA,OAAOA,KAAK,MAAM,OAAO;AAEzB,MAAMC,QAAQ,GAAG,2BAA2B;;AAE5C;AACA,MAAMC,GAAG,GAAGF,KAAK,CAACG,MAAM,CAAC;EACvBC,OAAO,EAAEH;AACX,CAAC,CAAC;;AAEF;AACAC,GAAG,CAACG,YAAY,CAACC,OAAO,CAACC,GAAG,CACzBC,MAAM,IAAK;EACV,MAAMC,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,aAAa,CAAC;EACjD,IAAIF,KAAK,EAAE;IACTD,MAAM,CAACI,OAAO,CAAC,eAAe,CAAC,GAAG,SAAS,GAAGH,KAAK;EACrD;EACA,OAAOD,MAAM;AACf,CAAC,EACAK,KAAK,IAAK;EACT,OAAOC,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC;AAC9B,CACF,CAAC;;AAED;AACA,IAAIG,YAAY,GAAG,KAAK;;AAExB;AACAd,GAAG,CAACG,YAAY,CAACY,QAAQ,CAACV,GAAG,CAC1BU,QAAQ,IAAK;EACZ;EACA,OAAOA,QAAQ;AACjB,CAAC,EACD,MAAOJ,KAAK,IAAK;EACf,MAAMK,eAAe,GAAGL,KAAK,CAACL,MAAM;;EAEpC;EACA,IAAIK,KAAK,CAACI,QAAQ,CAACE,MAAM,KAAK,GAAG,IAAI,CAACD,eAAe,CAACE,MAAM,EAAE;IAE5D,IAAIJ,YAAY,EAAE;MAChB;MACA,OAAOF,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC;IAC9B;IAEAK,eAAe,CAACE,MAAM,GAAG,IAAI,CAAC,CAAC;IAC/BJ,YAAY,GAAG,IAAI;IAEnB,MAAMK,YAAY,GAAGX,YAAY,CAACC,OAAO,CAAC,cAAc,CAAC;IAEzD,IAAI;MACF;MACA,MAAMW,EAAE,GAAG,MAAMtB,KAAK,CAACuB,IAAI,CAAC,GAAGtB,QAAQ,eAAe,EAAE;QACtDoB,YAAY,EAAEA;MAChB,CAAC,CAAC;MAEF,MAAM;QAAEG;MAAY,CAAC,GAAGF,EAAE,CAACG,IAAI;;MAE/B;MACAf,YAAY,CAACgB,OAAO,CAAC,aAAa,EAAEF,WAAW,CAAC;;MAEhD;MACAtB,GAAG,CAACyB,QAAQ,CAACf,OAAO,CAACgB,MAAM,CAAC,eAAe,CAAC,GAAG,SAAS,GAAGJ,WAAW;MACtE;MACAN,eAAe,CAACN,OAAO,CAAC,eAAe,CAAC,GAAG,SAAS,GAAGY,WAAW;MAElER,YAAY,GAAG,KAAK;;MAEpB;MACA,OAAOd,GAAG,CAACgB,eAAe,CAAC;IAE7B,CAAC,CAAC,OAAOW,MAAM,EAAE;MACf;MACAC,OAAO,CAACjB,KAAK,CAAC,0CAA0C,EAAEgB,MAAM,CAAC;;MAEjE;MACAnB,YAAY,CAACqB,UAAU,CAAC,aAAa,CAAC;MACtCrB,YAAY,CAACqB,UAAU,CAAC,cAAc,CAAC;MACvCrB,YAAY,CAACqB,UAAU,CAAC,MAAM,CAAC;MAE/Bf,YAAY,GAAG,KAAK;;MAEpB;MACA;MACAgB,MAAM,CAACC,QAAQ,CAACC,IAAI,GAAG,GAAG;MAE1B,OAAOpB,OAAO,CAACC,MAAM,CAACc,MAAM,CAAC;IAC/B;EACF;;EAEA;EACA,OAAOf,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC;AAC9B,CACF,CAAC;AAED,eAAeX,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}